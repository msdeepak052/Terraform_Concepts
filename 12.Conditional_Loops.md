# **1ï¸âƒ£ Conditionals in Terraform**

Terraform supports **ternary-style conditionals** and `if expressions` to make decisions dynamically.

### **Syntax (Ternary style)**

```hcl
condition ? true_value : false_value
```

### **Example 1: Basic conditional**

```hcl
variable "env" {
  default = "dev"
}

output "instance_type" {
  value = var.env == "prod" ? "t3.large" : "t2.micro"
}
```

* `env=dev` â†’ `t2.micro`
* `env=prod` â†’ `t3.large`

### **Example 2: Conditional with lists**

```hcl
variable "env" {
  default = "dev"
}

variable "azs" {
  default = ["ap-south-1a", "ap-south-1b"]
}

output "selected_azs" {
  value = var.env == "prod" ? var.azs : [var.azs[0]]
}
```

* For `prod` â†’ all AZs
* For `dev` â†’ only the first AZ

### **Example 3: Conditional with maps**

```hcl
variable "env" {
  default = "qa"
}

output "tags" {
  value = var.env == "prod" ? {Environment="prod", Owner="Ops"} : {Environment=var.env, Owner="Dev"}
}
```

âœ… Conditionals allow **dynamic resource configuration** based on environment, region, or any variable.

---

# **2ï¸âƒ£ Loops in Terraform**

Terraform has multiple ways to loop: `count`, `for_each`, and `for expressions`. Each has **different use-cases**.

---

## **2a. count**

* `count` lets you create **multiple instances of a resource**.
* Works with **number type**.

### **Example 1: Create multiple EC2 instances**

```hcl
variable "instance_count" {
  default = 3
}

resource "aws_instance" "web" {
  count         = var.instance_count
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  tags = {
    Name = "web-${count.index}"
  }
}
```

* Creates 3 EC2 instances: `web-0`, `web-1`, `web-2`.

### **Example 2: Conditional count**

```hcl
variable "create_instance" {
  default = true
}

resource "aws_instance" "conditional" {
  count = var.create_instance ? 1 : 0
  ami   = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
}
```

* Creates the instance **only if `create_instance=true`**.

---

## **2b. for_each**

* `for_each` works with **maps or sets**.
* Each element becomes a separate resource with a **unique key**.

### **Example 1: Multiple EC2 instances with map**

```hcl
variable "servers" {
  default = {
    "web" = "t2.micro"
    "app" = "t2.small"
  }
}

resource "aws_instance" "multi" {
  for_each      = var.servers
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = each.value
  tags = {
    Name = each.key
  }
}
```

* Creates two instances:

  * `web` â†’ `t2.micro`
  * `app` â†’ `t2.small`

### **Example 2: for_each with set**

```hcl
variable "envs" {
  default = ["dev","qa","prod"]
}

resource "aws_s3_bucket" "buckets" {
  for_each = toset(var.envs)
  bucket   = "mybucket-${each.key}"
  acl      = "private"
}
```

* Creates 3 S3 buckets: `mybucket-dev`, `mybucket-qa`, `mybucket-prod`.

---

## **2c. for expressions**

* `for expressions` let you **transform lists or maps** into another list or map.
* Useful to **compute dynamic values**.

### **Example 1: Transform list**

```hcl
variable "azs" {
  default = ["ap-south-1a", "ap-south-1b"]
}

output "upper_azs" {
  value = [for az in var.azs : upper(az)]
}
```

**Output:** `["AP-SOUTH-1A","AP-SOUTH-1B"]`

### **Example 2: Map from list**

```hcl
variable "servers" {
  default = ["web","app"]
}

output "server_map" {
  value = {for s in var.servers : s => "${s}-instance"}
}
```

**Output:** `{"web"="web-instance", "app"="app-instance"}`

### **Example 3: Conditional in for expression**

```hcl
variable "envs" {
  default = ["dev","qa","prod"]
}

output "prod_only" {
  value = [for e in var.envs : e if e == "prod"]
}
```

**Output:** `["prod"]`

---

# ðŸŒŸ **1ï¸âƒ£ What is a `for` expression in Terraform?**

A **`for` expression** lets you **transform or filter** elements from a **map or list** into a **new map or list**.

### **Syntax (for maps):**

```hcl
{ for key, value in map : key => new_value }
```

Optionally, you can include a condition:

```hcl
{ for key, value in map : key => new_value if condition }
```

---

# **2ï¸âƒ£ Basic Example â€” Transform Map Values**

Suppose we have a map of environments with region names:

```hcl
variable "env_regions" {
  default = {
    dev  = "ap-south-1"
    qa   = "us-east-1"
    prod = "eu-west-1"
  }
}
```

### âœ… Example: Convert regions to uppercase

```hcl
output "upper_regions" {
  value = { for env, region in var.env_regions : env => upper(region) }
}
```

**Output:**

```hcl
{
  "dev"  = "AP-SOUTH-1"
  "qa"   = "US-EAST-1"
  "prod" = "EU-WEST-1"
}
```

âœ”ï¸ Each key stays the same, and each value is **transformed** with `upper()`.

---

# **3ï¸âƒ£ Example â€” Filter and Transform a Map**

### Suppose we want to show only non-production environments:

```hcl
output "non_prod_envs" {
  value = { for k, v in var.env_regions : k => v if k != "prod" }
}
```

**Output:**

```hcl
{
  "dev" = "ap-south-1"
  "qa"  = "us-east-1"
}
```

âœ”ï¸ The `if` condition filters out `prod`.

---

# **4ï¸âƒ£ Example â€” Create New Maps with Computed Values**

### Letâ€™s assume we want to add a suffix (`-backup`) to each region name.

```hcl
output "backup_regions" {
  value = { for env, region in var.env_regions : env => "${region}-backup" }
}
```

**Output:**

```hcl
{
  "dev"  = "ap-south-1-backup"
  "qa"   = "us-east-1-backup"
  "prod" = "eu-west-1-backup"
}
```

âœ”ï¸ Here weâ€™ve dynamically **constructed new strings** per map entry.

---

# **5ï¸âƒ£ Example â€” Nested Map Transformation**

You can even **transform nested maps** (maps of maps).

```hcl
variable "server_info" {
  default = {
    web = { type = "t2.micro", region = "ap-south-1" }
    app = { type = "t2.small", region = "us-east-1" }
    db  = { type = "t3.medium", region = "eu-west-1" }
  }
}
```

### âœ… Example: Create new map with just instance types

```hcl
output "instance_types" {
  value = { for name, details in var.server_info : name => details.type }
}
```

**Output:**

```hcl
{
  "web" = "t2.micro"
  "app" = "t2.small"
  "db"  = "t3.medium"
}
```

---

# **6ï¸âƒ£ Example â€” Conditional Transform (if within for)**

Now, letâ€™s say we want to **label only â€œprod-likeâ€ servers differently**.

```hcl
output "server_labels" {
  value = {
    for name, details in var.server_info :
    name => (details.type == "t3.medium" ? "production-server" : "standard-server")
  }
}
```

**Output:**

```hcl
{
  "web" = "standard-server"
  "app" = "standard-server"
  "db"  = "production-server"
}
```

âœ”ï¸ Here we used a **ternary operator inside the for expression**.

---

# **7ï¸âƒ£ Example â€” Complex Combination (Filter + Transform)**

Combine everything:
Filter out QA servers and transform the rest.

```hcl
output "filtered_servers" {
  value = {
    for name, details in var.server_info :
    name => "${details.region}-${details.type}" if name != "app"
  }
}
```

**Output:**

```hcl
{
  "web" = "ap-south-1-t2.micro"
  "db"  = "eu-west-1-t3.medium"
}
```

âœ”ï¸ Only `web` and `db` are included, with formatted values.

---

# **8ï¸âƒ£ Real-Life Example â€” Tag Creation Map**

In real-world Terraform modules, `for` expressions are commonly used for **dynamic tagging**.

```hcl
variable "base_tags" {
  default = {
    Environment = "dev"
    Owner       = "Deepak"
    Project     = "BankApp"
  }
}

variable "extra_tags" {
  default = {
    CostCenter = "FIN001"
    Department = "DevOps"
  }
}

# Merge and transform tag values to uppercase
output "merged_tags" {
  value = {
    for k, v in merge(var.base_tags, var.extra_tags) : k => upper(v)
  }
}
```

**Output:**

```hcl
{
  "Environment" = "DEV"
  "Owner"       = "DEEPAK"
  "Project"     = "BANKAPP"
  "CostCenter"  = "FIN001"
  "Department"  = "DEVOPS"
}
```

âœ”ï¸ Youâ€™ve now dynamically merged maps and formatted their values â€” a common enterprise use case.

---

# **9ï¸âƒ£ Summary Table**

| Type            | Syntax                                           | Description                             | Example                             |
| --------------- | ------------------------------------------------ | --------------------------------------- | ----------------------------------- |
| Basic Transform | `{ for k, v in map : k => v * 2 }`               | Create new map with modified values     | Transform prices or sizes           |
| Filter          | `{ for k, v in map : k => v if v > 10 }`         | Include items only if condition matches | Filter expensive resources          |
| Conditional     | `{ for k, v in map : k => (v=="x"?"yes":"no") }` | Ternary condition inside map            | Dynamic labeling                    |
| Nested          | `{ for k, v in map : k => v.field }`             | Extract sub-values                      | Get instance types from nested maps |

---

# ðŸ’¡ **Real-World Usage Recap**

âœ… Common use cases for `for` with maps:

* Dynamic tagging (merging or transforming maps)
* Filtering out unwanted environments
* Generating resource-specific names
* Selecting or transforming nested resource data
* Creating variables for modules dynamically


---

# **2d. if expressions inside for expressions**

* You can **filter or compute values conditionally**.

### **Example 1: Conditional tags**

```hcl
variable "servers" {
  default = ["web","app","db"]
}

output "tags" {
  value = {for s in var.servers : s => (s=="db" ? "database" : "application")}
}
```

**Output:** `{"web"="application","app"="application","db"="database"}`

### **Example 2: Filter list**

```hcl
variable "envs" {
  default = ["dev","qa","prod"]
}

output "non_prod" {
  value = [for e in var.envs : e if e != "prod"]
}
```

**Output:** `["dev","qa"]`

---
Letâ€™s go **deep** into how to use **`for_each`** and **`for` expressions** with **objects** â€” since objects are one of the most flexible and realistic data structures in Terraform.

---

## ðŸ§© 1ï¸âƒ£ Understanding Objects in Terraform

An **object** in Terraform is like a JSON dictionary â€” it holds **key-value pairs** where values can be of different types.

Example:

```hcl
variable "servers" {
  type = map(object({
    instance_type = string
    ami           = string
    env           = string
  }))
  default = {
    web = {
      instance_type = "t2.micro"
      ami           = "ami-0abcdef1234567890"
      env           = "dev"
    }
    app = {
      instance_type = "t2.small"
      ami           = "ami-0abcdef1234567890"
      env           = "staging"
    }
  }
}
```

---

## ðŸš€ 2ï¸âƒ£ Using `for_each` with Objects

When using `for_each`, Terraform automatically iterates over the **keys** of a map or object.

Example:

```hcl
resource "aws_instance" "servers" {
  for_each = var.servers

  ami           = each.value.ami
  instance_type = each.value.instance_type
  tags = {
    Name = "${each.key}-server"
    Env  = each.value.env
  }
}
```

### ðŸ’¡ Explanation:

* `each.key` â†’ gives the map key (like `web`, `app`)
* `each.value` â†’ gives the value (the object `{ ami, instance_type, env }`)
* Terraform creates one EC2 instance **per object key**

### ðŸ§  Output Example

```hcl
output "server_ids" {
  value = { for key, instance in aws_instance.servers : key => instance.id }
}
```

This produces a **map of instance IDs**:

```hcl
server_ids = {
  "web" = "i-0a12b345cde6f7890"
  "app" = "i-0f12e345cde6b7890"
}
```

---

## ðŸ” 3ï¸âƒ£ Using `for` Expressions with Objects

A **`for` expression** lets you transform or filter object data.

### âœ… Example 1: Extract only AMIs from the object

```hcl
locals {
  amis = { for name, cfg in var.servers : name => cfg.ami }
}

output "ami_list" {
  value = local.amis
}
```

**Output:**

```hcl
{
  "web" = "ami-0abcdef1234567890"
  "app" = "ami-0abcdef1234567890"
}
```

---

### âœ… Example 2: Filter specific objects (only "dev" servers)

```hcl
locals {
  dev_servers = {
    for name, cfg in var.servers :
    name => cfg
    if cfg.env == "dev"
  }
}

output "dev_servers" {
  value = local.dev_servers
}
```

**Output:**

```hcl
{
  "web" = {
    instance_type = "t2.micro"
    ami           = "ami-0abcdef1234567890"
    env           = "dev"
  }
}
```

---

### âœ… Example 3: Create a formatted string list from object

```hcl
locals {
  server_summary = [
    for name, cfg in var.servers :
    "${name}: ${cfg.instance_type} in ${cfg.env} using ${cfg.ami}"
  ]
}

output "server_summary" {
  value = local.server_summary
}
```

**Output:**

```hcl
[
  "web: t2.micro in dev using ami-0abcdef1234567890",
  "app: t2.small in staging using ami-0abcdef1234567890"
]
```

---

## ðŸ’ª Combine `for_each` + `for` Expression (Advanced Example)

```hcl
resource "aws_instance" "dynamic_servers" {
  for_each = {
    for name, cfg in var.servers :
    name => cfg
    if cfg.env != "staging"  # deploy only non-staging
  }

  ami           = each.value.ami
  instance_type = each.value.instance_type

  tags = {
    Name = "${each.key}-server"
    Environment = each.value.env
  }
}

output "active_instances" {
  value = { for k, inst in aws_instance.dynamic_servers : k => inst.private_ip }
}
```

**Result:**
Terraform will only create EC2 instances where `env != "staging"` and return their private IPs.

---

## ðŸ§  Summary

| Concept              | Used For                                | Input Type            | Access Syntax                          |
| -------------------- | --------------------------------------- | --------------------- | -------------------------------------- |
| **`for_each`**       | Creating multiple resources dynamically | Map or Set of Strings | `each.key`, `each.value`               |
| **`for` expression** | Transforming or filtering maps/lists    | List or Map/Object    | `for k,v in map : k => v if condition` |

---

# **3ï¸âƒ£ Real-Life Example Combining Everything**

Suppose we want to create **multiple EC2 instances** with **different types based on environment**, and **output their names and IDs dynamically**:

```hcl
variable "envs" {
  default = ["dev","qa","prod"]
}

variable "instance_type_map" {
  default = {
    dev  = "t2.micro"
    qa   = "t2.small"
    prod = "t3.large"
  }
}

resource "aws_instance" "web" {
  for_each = toset(var.envs)
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = var.instance_type_map[each.key]
  tags = {
    Name = "${each.key}-web"
    Env  = each.key
  }
}

output "instance_info" {
  value = {for k, v in aws_instance.web : k => v.id}
}
```

âœ… This dynamically:

* Creates instances per environment
* Picks instance type using a map (conditional logic)
* Uses `for_each` and `for expression` to output a map of instance IDs

---

# **Summary Table**

| Feature             | Purpose                   | Data Types                | Example                                 |
| ------------------- | ------------------------- | ------------------------- | --------------------------------------- |
| Conditional (`? :`) | Choose values dynamically | string, number, list, map | `var.env=="prod"?"t3.large":"t2.micro"` |
| `count`             | Repeat resource N times   | number                    | `count=3`                               |
| `for_each`          | Loop over map or set      | map, set                  | `for_each=var.servers`                  |
| `for expression`    | Transform list/map        | list, map                 | `[for az in var.azs: upper(az)]`        |
| `if expression`     | Conditional inside for    | list, map                 | `[for e in var.envs: e if e!="prod"]`   |

---
