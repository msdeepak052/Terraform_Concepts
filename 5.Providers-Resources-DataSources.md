## 🧱 1️⃣ PROVIDERS

### 💡 **Definition**

A **provider** is a plugin that lets Terraform communicate with an external platform — like AWS, Azure, GCP, Kubernetes, GitHub, etc.

Each provider exposes **resources** and **data sources** that Terraform can manage or read.

---

### 🧩 **Example – AWS Provider**

```hcl
provider "aws" {
  region  = "ap-south-1"
  profile = "default"
}
```

🔹 Here:

* `aws` → is the provider name.
* `region` → where resources will be created.
* `profile` → uses credentials from `~/.aws/credentials`.

When you run:

```bash
terraform init
```

Terraform downloads the `hashicorp/aws` plugin and stores it in `.terraform/providers`.

---

### ✅ **Key Points**

* Providers are developed and maintained by **HashiCorp** or **community contributors**.
* Each provider has a **version**, locked in `.terraform.lock.hcl`.
* You can **pin provider versions** to avoid breaking changes:

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.18"
    }
  }
}
```

---

## 🏗️ 2️⃣ RESOURCES

### 💡 **Definition**

A **resource** is **something Terraform creates, updates, or deletes** in your provider environment.
Examples:

* EC2 instance (AWS)
* Resource group (Azure)
* Namespace (Kubernetes)

Think of **resources** as the **actual infrastructure components** Terraform manages.

---

### 🧩 **Example – AWS EC2 Instance**

```hcl
resource "aws_instance" "webserver" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
  tags = {
    Name = "Deepak-EC2"
  }
}
```

🔹 Here:

* `resource` → Terraform keyword.
* `"aws_instance"` → resource type from the AWS provider.
* `"webserver"` → resource name (local reference).
* Inside the block, you define **arguments** (like `ami`, `instance_type`, `tags`).

---

### ⚙️ **How Terraform Manages Resources**

* Terraform stores the **resource’s real-world ID** in the **state file (`terraform.tfstate`)**.
* On each `terraform plan`, it compares the current configuration (`.tf` files) with the state file to see if any changes are needed.

---

### 🧩 **Example – Adding Another Resource**

You can have multiple resources in the same file:

```hcl
resource "aws_s3_bucket" "mybucket" {
  bucket = "deepak-demo-bucket"
  acl    = "private"
}
```

Now Terraform manages both:

* EC2 instance
* S3 bucket

---

## 🔍 3️⃣ DATA SOURCES

### 💡 **Definition**

A **data source** is **read-only information** that Terraform can **fetch from a provider**.
You use data sources to **query existing resources** instead of creating new ones.

For example:

* Get the latest Amazon Linux AMI ID.
* Get an existing VPC ID.
* Get the current AWS caller identity.

---

### 🧩 **Example – Get Latest AMI**

```hcl
data "aws_ami" "latest_amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}
```

Now you can **use this AMI** inside a resource:

```hcl
resource "aws_instance" "webserver" {
  ami           = data.aws_ami.latest_amazon_linux.id
  instance_type = "t2.micro"
}
```

🔹 Here:

* `data.aws_ami.latest_amazon_linux.id` dynamically fetches the latest AMI ID.
* No need to hardcode AMI IDs — they update automatically.

---

### 🧩 **Example – Get Existing VPC**

```hcl
data "aws_vpc" "default" {
  default = true
}

output "vpc_id" {
  value = data.aws_vpc.default.id
}
```

This doesn’t create a VPC — it only *reads* the existing default one.

---

## 🧠 Summary Table

| Concept         | Purpose                                                 | Action                | Example                                    |
| --------------- | ------------------------------------------------------- | --------------------- | ------------------------------------------ |
| **Provider**    | Connect Terraform to a platform (AWS, Azure, GCP, etc.) | Configure connection  | `provider "aws" { region = "ap-south-1" }` |
| **Resource**    | Create/manage infrastructure objects                    | Create/update/destroy | `resource "aws_instance" "myec2" { ... }`  |
| **Data Source** | Read existing info from provider                        | Read-only             | `data "aws_ami" "latest" { ... }`          |

---

## 📁 Typical Folder Example

```
Terraform/
├── main.tf               # provider + resources
├── variables.tf          # variable definitions
├── outputs.tf            # output values
├── terraform.tfstate     # state tracking
├── .terraform/            # plugin cache
└── .terraform.lock.hcl    # provider version lock
```

---
Let’s walk through a **real working example** that includes all three Terraform components:

✅ **Provider** → AWS
✅ **Data Source** → Fetch latest Amazon Linux 2 AMI
✅ **Resource** → Launch EC2 instance using that AMI

---

## 📁 Folder structure

```
Terraform/
├── main.tf
├── variables.tf
├── outputs.tf
```

---

## 🧩 **1️⃣ main.tf**

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }

  required_version = ">= 1.5.0"
}

provider "aws" {
  region = "ap-south-1"   # Mumbai region
}

# 🔍 Data Source: Fetch the latest Amazon Linux 2 AMI dynamically
data "aws_ami" "latest_amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

# 🏗️ Resource: Create an EC2 instance using the AMI above
resource "aws_instance" "deepak_ec2" {
  ami           = data.aws_ami.latest_amazon_linux.id
  instance_type = var.instance_type

  tags = {
    Name = "Deepak-EC2"
    Project = "Terraform-Demo"
  }
}
```

---

## ⚙️ **2️⃣ variables.tf**

```hcl
# Define variables for reusable values

variable "instance_type" {
  description = "Type of EC2 instance"
  type        = string
  default     = "t2.micro"
}
```

---

## 📤 **3️⃣ outputs.tf**

```hcl
# Show instance details after apply

output "ec2_instance_id" {
  description = "EC2 Instance ID"
  value       = aws_instance.deepak_ec2.id
}

output "ec2_public_ip" {
  description = "EC2 Public IP"
  value       = aws_instance.deepak_ec2.public_ip
}

output "ami_used" {
  description = "AMI ID fetched dynamically"
  value       = data.aws_ami.latest_amazon_linux.id
}
```

---

## 🚀 **Commands to Run**

Run these step-by-step in your Terraform directory:

```bash
terraform init          # Initialize provider plugins (AWS)
terraform validate      # Check syntax
terraform plan          # Preview what will be created
terraform apply         # Create EC2 instance
```

Example output during apply:

```
Plan: 1 to add, 0 to change, 0 to destroy.

aws_instance.deepak_ec2: Creating...
aws_instance.deepak_ec2: Creation complete after 40s [id=i-0a12b3c45d67e89f0]

Outputs:
ami_used = "ami-0abcdef1234567890"
ec2_instance_id = "i-0a12b3c45d67e89f0"
ec2_public_ip = "3.110.92.8"
```

---

## 🧠 **How this example connects the dots**

| Concept         | Defined in     | Function                     |
| --------------- | -------------- | ---------------------------- |
| **Provider**    | `main.tf`      | Connects to AWS              |
| **Data Source** | `main.tf`      | Fetches latest AMI           |
| **Resource**    | `main.tf`      | Creates EC2 instance         |
| **Variable**    | `variables.tf` | Parameterizes instance type  |
| **Output**      | `outputs.tf`   | Displays results after apply |

---

## 💣 **Destroy when done**

To clean up:

```bash
terraform destroy
```

---
