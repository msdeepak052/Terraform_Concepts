## 🧩 1. `terraform init`

### **Purpose:**

Initializes a new or existing Terraform working directory.
It downloads provider plugins (like AWS, Azure, etc.), sets up the backend, and prepares the environment.

### **Example:**

```bash
terraform init
```

### **What happens:**

* Downloads the provider mentioned in your `.tf` files (e.g., `hashicorp/aws`).
* Initializes the backend for storing Terraform state.
* Creates a `.terraform/` directory.

✅ **Use this when:**
You start a new project or add/change providers/backends.


Let’s break down what happens **after `terraform init`** and what each folder/file in your working directory means.

From your output, you have these files/folders:

```
.terraform/
.terraform.lock.hcl
maint.tf
```

---

## 1️⃣ `.terraform/`  (directory)

* **Purpose:** This is Terraform’s **working directory** where it stores **plugins, modules, and internal data** needed for operations.
* **What’s inside?**

  * `plugins/` → downloaded provider binaries, e.g., `aws`.
  * `modules/` → cached modules if you use external modules.
  * Sometimes there’s `providers.json` or other metadata files Terraform uses internally.

**Key point:**

* You **do not manually edit** anything inside `.terraform/`.
* It can usually be ignored in Git by adding it to `.gitignore`.

---

## 2️⃣ `.terraform.lock.hcl`  (file)

* **Purpose:** **Locks provider versions** to ensure consistency across machines or team members.
* Created automatically when Terraform downloads provider plugins.

**Why it’s important:**

* If you run `terraform init` on another machine, Terraform will install the **exact same provider versions** recorded here.
* Prevents unexpected changes if a newer provider version has breaking changes.

**Example content:**

```hcl
provider "registry.terraform.io/hashicorp/aws" {
  version     = "6.18.0"
  constraints = "~> 6.18"
  hashes = [
    "h1:xxxx...",
  ]
}
```

---

## 3️⃣ Your Terraform configuration file (`maint.tf`)

* This is your **actual infrastructure code**.
* Typically written in **HCL** (HashiCorp Configuration Language).
* Contains:

  * **Providers** (AWS, Azure, GCP, etc.)
  * **Resources** (EC2, S3, VPC, etc.)
  * **Variables, outputs, modules** if used.

Example snippet for AWS EC2:

```hcl
provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "my_ec2" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
}
```

---

## ⚡ How it all fits together

| File/Folder           | Purpose                                                       |
| --------------------- | ------------------------------------------------------------- |
| `.terraform/`         | Stores provider plugins, modules, and Terraform internal data |
| `.terraform.lock.hcl` | Locks provider versions for consistency                       |
| `maint.tf`            | Your main Terraform configuration file                        |

---

### 💡 Summary

1. **Run `terraform init`** → downloads providers, sets up backend, creates `.terraform/` and `.terraform.lock.hcl`.
2. `.terraform/` → internal folder, don’t edit.
3. `.terraform.lock.hcl` → ensures version consistency.
4. `*.tf` files → **you write and manage these** to define infrastructure.

---

---

## 🗺️ 2. `terraform plan`

### **Purpose:**

Previews what Terraform will do — **without actually changing anything.**

### **Example:**

```bash
terraform plan
```

### **What happens:**

* Reads your configuration files.
* Compares them with the real infrastructure (using the state file).
* Shows what will be **created, modified, or destroyed**.

Example output:

```
Plan: 1 to add, 0 to change, 0 to destroy.
```

✅ **Use this when:**
You want to verify what changes Terraform will make before applying them.

---

## ⚙️ 3. `terraform apply`

### **Purpose:**

Applies the plan — actually creates or modifies infrastructure.

### **Example:**

```bash
terraform apply
```

Terraform will:

* Show you the same plan preview.
* Ask for confirmation (`yes`).
* Create the infrastructure.

You can also auto-approve:

```bash
terraform apply -auto-approve
```

✅ **Use this when:**
You’re ready to deploy or update your infrastructure.

---

## 💣 4. `terraform destroy`

### **Purpose:**

Deletes all resources defined in your Terraform configuration.

### **Example:**

```bash
terraform destroy
```

Terraform will:

* Show a destruction plan.
* Ask for confirmation before deleting everything.

Auto-confirm version:

```bash
terraform destroy -auto-approve
```

✅ **Use this when:**
You want to tear down all infrastructure (e.g., after testing).

---

## 🧹 5. `terraform fmt`

### **Purpose:**

Formats `.tf` files to a **standard, readable style**.

### **Example:**

```bash
terraform fmt
```

### **What happens:**

* Automatically reformats Terraform files.
* Makes your code cleaner and consistent.

✅ **Use this when:**
You want to maintain code quality and readability (especially before committing to Git).

---

## ✅ 6. `terraform validate`

### **Purpose:**

Checks if your configuration is **syntactically valid** and **internally consistent**.

### **Example:**

```bash
terraform validate
```

### **What happens:**

* Detects syntax errors.
* Ensures required arguments are present.
* Checks for invalid provider blocks or variables.

✅ **Use this when:**
You want to verify your `.tf` code before running `plan` or `apply`.

---

## ⚡ Example Workflow Summary

Let’s say you’re deploying an EC2 instance using Terraform:

```bash
terraform init         # Initialize Terraform project
terraform validate     # Check syntax and structure
terraform plan         # Preview what will be created
terraform apply        # Deploy the EC2 instance
terraform fmt          # Format files neatly
terraform destroy      # Delete the EC2 instance
```

---
