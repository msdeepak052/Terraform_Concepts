## üß© 1. `terraform init`

### **Purpose:**

Initializes a new or existing Terraform working directory.
It downloads provider plugins (like AWS, Azure, etc.), sets up the backend, and prepares the environment.

### **Example:**

```bash
terraform init
```

### **What happens:**

* Downloads the provider mentioned in your `.tf` files (e.g., `hashicorp/aws`).
* Initializes the backend for storing Terraform state.
* Creates a `.terraform/` directory.

‚úÖ **Use this when:**
You start a new project or add/change providers/backends.


Let‚Äôs break down what happens **after `terraform init`** and what each folder/file in your working directory means.

From your output, you have these files/folders:

```
.terraform/
.terraform.lock.hcl
maint.tf
```

---

## 1Ô∏è‚É£ `.terraform/`  (directory)

* **Purpose:** This is Terraform‚Äôs **working directory** where it stores **plugins, modules, and internal data** needed for operations.
* **What‚Äôs inside?**

  * `plugins/` ‚Üí downloaded provider binaries, e.g., `aws`.
  * `modules/` ‚Üí cached modules if you use external modules.
  * Sometimes there‚Äôs `providers.json` or other metadata files Terraform uses internally.

**Key point:**

* You **do not manually edit** anything inside `.terraform/`.
* It can usually be ignored in Git by adding it to `.gitignore`.

---

## 2Ô∏è‚É£ `.terraform.lock.hcl`  (file)

* **Purpose:** **Locks provider versions** to ensure consistency across machines or team members.
* Created automatically when Terraform downloads provider plugins.

**Why it‚Äôs important:**

* If you run `terraform init` on another machine, Terraform will install the **exact same provider versions** recorded here.
* Prevents unexpected changes if a newer provider version has breaking changes.

**Example content:**

```hcl
provider "registry.terraform.io/hashicorp/aws" {
  version     = "6.18.0"
  constraints = "~> 6.18"
  hashes = [
    "h1:xxxx...",
  ]
}
```

---

## 3Ô∏è‚É£ Your Terraform configuration file (`maint.tf`)

* This is your **actual infrastructure code**.
* Typically written in **HCL** (HashiCorp Configuration Language).
* Contains:

  * **Providers** (AWS, Azure, GCP, etc.)
  * **Resources** (EC2, S3, VPC, etc.)
  * **Variables, outputs, modules** if used.

Example snippet for AWS EC2:

```hcl
provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "my_ec2" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
}
```

---

## ‚ö° How it all fits together

| File/Folder           | Purpose                                                       |
| --------------------- | ------------------------------------------------------------- |
| `.terraform/`         | Stores provider plugins, modules, and Terraform internal data |
| `.terraform.lock.hcl` | Locks provider versions for consistency                       |
| `maint.tf`            | Your main Terraform configuration file                        |

---

### üí° Summary

1. **Run `terraform init`** ‚Üí downloads providers, sets up backend, creates `.terraform/` and `.terraform.lock.hcl`.
2. `.terraform/` ‚Üí internal folder, don‚Äôt edit.
3. `.terraform.lock.hcl` ‚Üí ensures version consistency.
4. `*.tf` files ‚Üí **you write and manage these** to define infrastructure.

---

---

## üó∫Ô∏è 2. `terraform plan`

### **Purpose:**

Previews what Terraform will do ‚Äî **without actually changing anything.**

### **Example:**

```bash
terraform plan
```

### **What happens:**

* Reads your configuration files.
* Compares them with the real infrastructure (using the state file).
* Shows what will be **created, modified, or destroyed**.

Example output:

```
Plan: 1 to add, 0 to change, 0 to destroy.
```

‚úÖ **Use this when:**
You want to verify what changes Terraform will make before applying them.

---

## ‚öôÔ∏è 3. `terraform apply`

### **Purpose:**

Applies the plan ‚Äî actually creates or modifies infrastructure.

### **Example:**

```bash
terraform apply
```

Terraform will:

* Show you the same plan preview.
* Ask for confirmation (`yes`).
* Create the infrastructure.

You can also auto-approve:

```bash
terraform apply -auto-approve
```
---

## üóÑÔ∏è `terraform.tfstate`

* **Purpose:** This is the **state file** where Terraform keeps track of your **real infrastructure**.
* It maps your `.tf` configuration to actual resources in the cloud.
* Terraform uses this file to know **what exists, what needs to be created, updated, or destroyed**.

### Example

Suppose you have this in your `maint.tf`:

```hcl
resource "aws_instance" "my_ec2" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
}
```

After running `terraform apply`, Terraform writes to `terraform.tfstate` something like:

```json
{
  "resources": [
    {
      "type": "aws_instance",
      "name": "my_ec2",
      "instances": [
        {
          "attributes": {
            "id": "i-0abcd1234efgh5678",
            "ami": "ami-12345678",
            "instance_type": "t2.micro",
            "tags": {}
          }
        }
      ]
    }
  ]
}
```

### Key Points:

1. **State Tracking:**
   Terraform doesn‚Äôt query the cloud every time; it relies on this file for quick planning and diff calculation.
2. **Sensitive Data:**
   This file can contain sensitive info like IPs, passwords, or IDs. Don‚Äôt expose it publicly.
3. **Collaboration:**

   * For a team, use **remote state** (S3, Terraform Cloud, etc.) to prevent conflicts.
   * Local `terraform.tfstate` is fine for learning or single-user projects.

---

### ‚ö° Workflow Example

```
1. terraform init       # initializes directory & providers
2. terraform plan       # reads state file & shows changes
3. terraform apply      # creates resources & updates state file
4. terraform destroy    # deletes resources & updates state file
```

The `terraform.tfstate` file is **automatically updated** after `apply` or `destroy`.

---



‚úÖ **Use this when:**
You‚Äôre ready to deploy or update your infrastructure.

---

## üí£ 4. `terraform destroy`

### **Purpose:**

Deletes all resources defined in your Terraform configuration.

### **Example:**

```bash
terraform destroy
```

Terraform will:

* Show a destruction plan.
* Ask for confirmation before deleting everything.

Auto-confirm version:

```bash
terraform destroy -auto-approve
```

‚úÖ **Use this when:**
You want to tear down all infrastructure (e.g., after testing).

---

## üßπ 5. `terraform fmt`

### **Purpose:**

Formats `.tf` files to a **standard, readable style**.

### **Example:**

```bash
terraform fmt
```

### **What happens:**

* Automatically reformats Terraform files.
* Makes your code cleaner and consistent.

‚úÖ **Use this when:**
You want to maintain code quality and readability (especially before committing to Git).

---

## ‚úÖ 6. `terraform validate`

### **Purpose:**

Checks if your configuration is **syntactically valid** and **internally consistent**.

### **Example:**

```bash
terraform validate
```

### **What happens:**

* Detects syntax errors.
* Ensures required arguments are present.
* Checks for invalid provider blocks or variables.

‚úÖ **Use this when:**
You want to verify your `.tf` code before running `plan` or `apply`.

---

## ‚ö° Example Workflow Summary

Let‚Äôs say you‚Äôre deploying an EC2 instance using Terraform:

```bash
terraform init         # Initialize Terraform project
terraform validate     # Check syntax and structure
terraform plan         # Preview what will be created
terraform apply        # Deploy the EC2 instance
terraform fmt          # Format files neatly
terraform destroy      # Delete the EC2 instance
```

---
